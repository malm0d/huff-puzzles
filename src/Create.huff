 
/** 
 *  CREATE HUFF EXERCISE
 *  
 *  The task is to deploy this contract with a function `makeContract()` which when called creates a contract
 *  that when called with any data returns `0xcaffe`.
 *  The call to `makeContract` should return the address of the newly created contract.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

//----------------------------------------FYI----------------------------------------
// We can get the creation code by creating the contract we want to deploy, and then use the huff compiler to get it.
// `huffc src/Caffe.huff --bytecode` ==> 600a8060093d393df3620caffe3d5260203df3
// Using evm.codes, we can get the runtime code for the Caffe contract by replication the instructions.
// This will return `620caffe3d5260203df3`.
// So we can infer that the init code is `600a8060093d393df3` and the runtime code is `620caffe3d5260203df3`
// Bytes for the init code is 9, and the bytes for the runtime code is 10.

// Mnemonic for Caffe contract / runtime code (evm.codes):
// PUSH3 0xcaffe
// RETURNDATASIZE   (compare: `PUSH1 0x00`, `PUSH0`)
// MSTORE
// PUSH1 0X20
// RETURNDATASIZE   (compare: `PUSH1 0x00`, `PUSH0`)
// RETURN

// If we replace `returndatasize` with `0x00` in src/Caffe.huff, this would be equivalent to using `PUSH0` in evm.codes
// and not `PUSH1 0x00`. If we used `PUSH1 0x00`, the runtime code retured from evm.codes will differ from huffc.
// huffc: 620caffe5f5260205ff3
// evm.codes: 620caffe60005260206000f3
// TLDR, using `0x00` is regarded as `PUSH0` and not `PUSH1 0x00`. This is why the runtime code differs.
// In evm.codes, if we use `PUSH0` instead, we will be able to get the same runtime code as huffc.
//-----------------------------------------------------------------------------------

#define function makeContract() payable returns(address)


#define macro MAIN() = takes(0) returns(0) {

}

//Creation code: 600a8060093d393df3 620caffe3d5260203df3
//
//INIT code: 600a8060093d393df3
// PUSH1 0x0a                           //[10] (is 10 the size of the runtime code?)
// DUP1                                 //[10, 10]
// PUSH1 0x09                           //[9, 10, 10] (is 9 the size of the init code?)              
// RETURNDATASIZE                       //[0, 9, 10, 10]
// CODECOPY                             //[10]  ==> codecopy(0, 9, 10) ==> copies 620caffe3d5260203df3 to memory @ 0x00
// RETURNDATASIZE                       //[0, 10] ==> offset 0, size 10 bytes      
// RETURN                               //[] ==> returns 620caffe3d5260203df3 from memory to the EVM,
//                                      //which will be the new contract's runtime code.
//
//Runtime code: 620caffe3d5260203df3
// PUSH3 0xcaffe
// RETURNDATASIZE
// MSTORE
// PUSH1 0X20
// RETURNDATASIZE
// RETURN
//
//Note, CODECOPY copies the code running in current environment to memory, so the running code is the creation code.
//Thus, codecopy(0, 9, 10) snips `620caffe3d5260203df3` from the creation code and stores it in memory @ 0x00.
//The init code takes this value from the memory @ 0x00 and returns it to the EVM.